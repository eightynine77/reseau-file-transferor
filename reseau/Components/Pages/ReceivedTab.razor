@page "/received"
@inject reseau.Services.FileTransferService NetService
@using System.IO
@using System.Linq
@implements IDisposable

<h3 class="mb-3">Inbox</h3>

<div class="card p-3 mb-3" style="background-color: #f0f0f0;">
    <label class="fw-bold">Save Location:</label>
    <div class="text-break mb-2 text-muted">
        @currentSavePath
    </div>
    <button class="btn btn-outline-primary btn-sm" @onclick="ChangeFolder">
        Change Folder
    </button>
</div>

<div class="d-flex justify-content-between align-items-center mb-3">
    <span>Received Files:</span>
    <button class="btn btn-sm btn-secondary" @onclick="RefreshFiles">Refresh</button>
</div>

@if (receivedFiles.Any())
{
    <div class="list-group">
        @foreach (var file in receivedFiles)
        {
            <div class="list-group-item">
                <span class="fw-bold">@file.Name</span>
                <br />
                <small class="text-muted">@file.SizeString</small>
            </div>
        }
    </div>
}
else
{
    <div class="alert alert-light text-center border">
        <p class="mb-0">No files received yet.</p>
    </div>
}

@code {
    private string currentSavePath;
    private List<FileDisplayModel> receivedFiles = new List<FileDisplayModel>();

    // --- 1. DEFINING THE MISSING CLASS ---
    private class FileDisplayModel
    {
        public string Name { get; set; }
        public string SizeString { get; set; }
    }

    protected override void OnInitialized()
    {
        currentSavePath = NetService.ReceivedFilesPath;
        NetService.OnFileReceived += HandleFileReceived;
        RefreshFiles();
    }

    private async Task ChangeFolder()
    {
        string newPath = await NetService.PickSaveLocationAsync();

        if (!string.IsNullOrEmpty(newPath))
        {
            currentSavePath = newPath;
            RefreshFiles();
        }
    }

    private void RefreshFiles()
    {
        try
        {
            var directory = NetService.ReceivedFilesPath;
            if (Directory.Exists(directory))
            {
                // --- 2. FIXING THE LOGIC TO USE THE CLASS ---
                // We use DirectoryInfo to get file details (like Size/Length)
                var dirInfo = new DirectoryInfo(directory);
                var files = dirInfo.GetFiles();

                receivedFiles = files.Select(f => new FileDisplayModel
                    {
                        Name = f.Name,
                    // We call the helper method to format the bytes nicely
                        SizeString = FormatSize(f.Length)
                    })
                .OrderByDescending(f => f.Name)
                .ToList();
            }
            else
            {
                receivedFiles.Clear();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading files: {ex.Message}");
        }
    }

    private async void HandleFileReceived()
    {
        await InvokeAsync(() =>
        {
            RefreshFiles();
            StateHasChanged();
        });
    }

    public void Dispose()
    {
        NetService.OnFileReceived -= HandleFileReceived;
    }

    // --- 3. ADDING THE MISSING HELPER METHOD ---
    private string FormatSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len = len / 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }
}